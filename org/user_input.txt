------------------------------------------
------------- Basic Ideas-----------------
------------------------------------------
First of all, what is a user input? In my opinion, a user input is a system
call(or an action) that reads information in from an I/O device except for
a disk file.

Currently we have 2 kinds of user input: from a local input device(keyboard
or mouse), and from network. There is no significant difference between them.

Basically we need 3 steps to deal with a user input:
1. Detect a user input
2. Match a user input
3. Replace the user input

We will discuss the 3 steps respectively in the following 3 parts.

------------------------------------------
-------------- Detection -----------------
------------------------------------------
According to the definition of user input, we need two conditions to check
whether an action is a user input action: (1) The action reads some
information [MW: add "from an I/O device", right?]; (2) The action interacts with an I/O device except for a disk
file. [MW: from the text, it looks like (1) is subsumed by (2), no? What
is the difference?]
[HW: (1) should be ``read information through network''. Linux provides clean
socket connection which is different from normal I/O operations and they need
to be considered differently.]

The first condition is trivial assuming that the system call list is fixed.
We can hard-code the system call list to reflect the relationship.

[MW: can you give an example of (2)?]

To check the second condition, we need to record the *actual* path of a
certain file descriptor. Remember that we have 2 kinds of user input currently.
For a network input, it's easy to record since they use unique system calls.
    [MW: not necessarily. sometimes processes read from the network or
    write to it with the read() and write() syscalls, where the fd is
    just the sockfd, no?]
For a read from I/O device, we need to track the path of a file descriptor,
if it's something in "/dev" we will consider the path to be a mapping to
an I/O device.

Problems here:
(1) What will happen when someone sends something to ``localhost''?
A: We do not replay network output, thus we won't duplicate packets. It has
no difference with packets from another machine.

(2) What will happen when someone wants to read from virtual device like
"/dev/zero"?
A: We skiped the actual execution of the action, and put the recorded value
instead. So it has no difference between using the recorded value and actually
reading from the device.

[MW: above two problems/answers are very nice. good thinking!]

------------------------------------------
------------- Matching -------------------
------------------------------------------
The most difficult part is here. Here is a simple method to deal with that:
Whenever there is a user input, match it to a recorded user input if:
(1) The recorded user input is never matched.
(2) The recorded user input is from the same device of current user input.

    [MW: when you say "match", is there a third condition (3), for
    instance that the actual content of the input matches, or no?]
    [HW: I do not think so. In fact we need to feed the actual content of
    the input recorded to a current user input, so they cannot be already
    the same.]

Problem here:
The approach works assuming the process is a deterministic machine that does
not change between the original execution and the current execution.

If the original base and the new base do not differ at the process to be
executed, then the process does not change.(If they differ, than there is
no way to fix that.) The problem here is whether a process is a deterministic
machine to user input? (A random value is in fact generated by a random
generator.) There are two factors which make the claim incorrect sometimes.
(1) A system call other than a user input might interfere. For example, a
process might use time() and determine something based on the return value.
(e.g. as the seed of a pseudo random generator.) time() is not a user input
but will differ from original execution and replay execution.

    [MW: can you address the above issue by having your record/replay
    module force time() to behave deterministically, on replay? Likewise
    for other sources of non-determinism? Or will "making it
    deterministic" not work because this is in fact a really hard
    problem in systems? (a problem that Retro seems to punt....)]
    [HW: It seems that we can force the results of ``time()'' to be the same
    , but it is doubtful that all the other system calls can also be forced
    to do the same thing. At least I think getpid() should return the current
    pid of a process instead of a pid it recorded previously.]

(2) A process might have multiple threads. The order of multiple threads
might interfere the behavior of a process.

    [MW: good point. How does Retro handle this case? Can you handle it
    by imagining that each thread (let's assume kernel-level threading,
    so the kernel knows about the threads and schedules them) is
    actually a process-lite that is part of a process group?]
    [HW: Retro only preserves dependency policy: If two actions are
    independent, Retro can replay them out of order. If actions behave
    differently during replay process, Retro simply uses the value in
    the replay process, and modifies its action graph to reflect these
    changes.]

    [HW: Currently I think the non-deterministic issue does not matter. Let's
    consider the two cases below:
    (1) The process prints out a different output to screen or other device,
    then there is a conflict which notifies the user the behavior has changed.
    (2) The process does not print a different output. In the case, a user or
    server has no way to recognize the difference between the replay process
    and the original process. Therefore repeating the original pattern of input
    is the reasonable behavior.
    The interesting point here is that in we can look at the problem in a
    user's point of view. When some information is input into the system, it is
    not distinguishable that which thread actually takes it. So no matter how
    the threads are scheduled, a user cannot see throught the difference, thus
    the user usually will not input something differently.] 

------------------------------------------
------------- Replacement ----------------
------------------------------------------
This part shall be easily carried out by using ptracing to hack the return
field with the recorded value. We also need to skip the execution of the certain
action whose return field is hacked.

    [MW: which actions do you need to skip executing? (I didn't follow
    the last sentence).]
    [HW: text changed to be more precise.]

------------------------------------------
------------ Additional Problems ---------
------------------------------------------
What will happen if a process asks the user ``What is the current time?'' and
modifies the system time according to the user's input?
Current Approach: in replaying, modify system time to the recorded value. The
behavior does not look like quite reasonable.
