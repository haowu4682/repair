------------------------------------------
------------- Basic Ideas-----------------
------------------------------------------
First of all, what is a user input? In my opinion, a user input is a system
call(or an action) that reads information in from an I/O device except for
a disk file.

Currently we have 2 kinds of user input: from a local input device(keyboard
or mouse), and from network. There is no significant difference between them.

Basically we need 3 steps to deal with a user input:
1. Detect a user input
2. Match a user input
3. Replace the user input

We will discuss the 3 steps respectively in the following 3 parts.

------------------------------------------
-------------- Detection -----------------
------------------------------------------
According to the definition of user input, we need two conditions to check
whether an action is a user input action: (1) The action reads some
information; (2) The action interacts with an I/O device except for a disk
file.

The first condition is trivial assuming that the system call list is fixed.
We can hard-code the system call list to reflect the relationship.

To check the second condition, we need to record the *actual* path of a
certain file descriptor. Remember that we have 2 kinds of user input currently.
For a network input, it's easy to record since they use unique system calls.
For a read from I/O device, we need to track the path of a file descriptor,
if it's something in "/dev" we will consider the path to be a mapping to
an I/O device.

Problems here:
(1) What will happen when someone sends something to ``localhost''?
A: We do not replay network output, thus we won't duplicate packets. It has
no difference with packets from another machine.

(2) What will happen when someone wants to read from virtual device like
"/dev/zero"?
A: We skiped the actual execution of the action, and put the recorded value
instead. So it has no difference between using the recorded value and actually
reading from the device.

------------------------------------------
------------- Matching -------------------
------------------------------------------
The most difficult part is here. Here is a simple method to deal with that:
Whenever there is a user input, match it to a recorded user input if:
(1) The recorded user input is never matched.
(2) The recorded user input is from the same device of current user input.

The approach works assuming the process is a deterministic machine that does
not change between the original execution and the current execution.

If the original base and the new base does not differ at the process to be
executed, then the process does not change.(If they differ, than there is
no way to fix that.) The problem here is whether a process is a deterministic
machine to user input? (A random value is in fact generated by a random
generator.) There are two factors which make the claim incorrect sometimes.
(1) A system call other than a user input might interfere. For example, a
process might use time() and determine something based on the return value.
(e.g. as the seed of a pseudo random generator.) time() is not a user input
but will differ from original execution and replay execution.
(2) A process might have multiple threads. The order of multiple threads
might interfere the behavior of a process.

------------------------------------------
------------- Replacement ----------------
------------------------------------------
This part shall be easily carried out by using ptracing to hack the return
field with the recorded value. We also need to skip the execution of a certain
action.

