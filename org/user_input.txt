------------------------------------------
------------- Basic Ideas-----------------
------------------------------------------
First of all, what is a user input? In my opinion, a user input is a system
call(or an action) that reads information in from an I/O device except for
a disk file.

Currently we have 2 kinds of user input: from a local input device(keyboard
or mouse), and from network. There is no significant difference between them.

Basically we need 3 steps to deal with a user input:
1. Detect a user input
2. Match a user input
3. Replace the user input

We will discuss the 3 steps respectively in the following 3 parts.

------------------------------------------
-------------- Detection -----------------
------------------------------------------
According to the definition of user input, we need two conditions to check
whether an action is a user input action: (1) The action reads some
information [MW: add "from an I/O device", right?]; (2) The action interacts with an I/O device except for a disk
file. [MW: from the text, it looks like (1) is subsumed by (2), no? What
is the difference?]
[HW: (1) should be ``read information through network''. Linux provides clean
socket connection which is different from normal I/O operations and they need
to be considered differently.]

The first condition is trivial assuming that the system call list is fixed.
We can hard-code the system call list to reflect the relationship.

[MW: can you give an example of (2)?]

To check the second condition, we need to record the *actual* path of a
certain file descriptor. Remember that we have 2 kinds of user input currently.
For a network input, it's easy to record since they use unique system calls.
    [MW: not necessarily. sometimes processes read from the network or
    write to it with the read() and write() syscalls, where the fd is
    just the sockfd, no?]
For a read from I/O device, we need to track the path of a file descriptor,
if it's something in "/dev" we will consider the path to be a mapping to
an I/O device.
UPDATE: the judgement is obsoleted. Currently a ``stat'' system call will be
executed, and whether a file is a device will be judged accordingly.

Problems here:
(1) What will happen when someone sends something to ``localhost''?
A: We do not replay network output, thus we won't duplicate packets. It has
no difference with packets from another machine.

(2) What will happen when someone wants to read from virtual device like
"/dev/zero"?
A: We skipped the actual execution of the action, and put the recorded value
instead. So it has no difference between using the recorded value and actually
reading from the device.

[MW: above two problems/answers are very nice. good thinking!]

------------------------------------------
------------- Matching -------------------
------------------------------------------
The most difficult part is here. Here is a simple method to deal with that:
Whenever there is a user input, match it to a recorded user input if:
(1) The recorded user input is never matched.
(2) The recorded user input is from the same device of current user input.

    [MW: when you say "match", is there a third condition (3), for
    instance that the actual content of the input matches, or no?]
    [HW: I do not think so. In fact we need to feed the actual content of
    the input recorded to a current user input, so they cannot be already
    the same.]

Problem here:
The approach works assuming the process is a deterministic machine that does
not change between the original execution and the current execution.

If the original base and the new base do not differ at the process to be
executed, then the process does not change.(If they differ, than there is
no way to fix that.) The problem here is whether a process is a deterministic
machine to user input? (A random value is in fact generated by a random
generator.) There are two factors which make the claim incorrect sometimes.
(1) A system call other than a user input might interfere. For example, a
process might use time() and determine something based on the return value.
(e.g. as the seed of a pseudo random generator.) time() is not a user input
but will differ from original execution and replay execution.

    [MW: can you address the above issue by having your record/replay
    module force time() to behave deterministically, on replay? Likewise
    for other sources of non-determinism? Or will "making it
    deterministic" not work because this is in fact a really hard
    problem in systems? (a problem that Retro seems to punt....)]
    [HW: It seems that we can force the results of ``time()'' to be the same
    , but it is doubtful that all the other system calls can also be forced
    to do the same thing. At least I think getpid() should return the current
    pid of a process instead of a pid it recorded previously.]

(2) A process might have multiple threads. The order of multiple threads
might interfere the behavior of a process.

    [MW: good point. How does Retro handle this case? Can you handle it
    by imagining that each thread (let's assume kernel-level threading,
    so the kernel knows about the threads and schedules them) is
    actually a process-lite that is part of a process group?]
    [HW: Retro only preserves dependency policy: If two actions are
    independent, Retro can replay them out of order. If actions behave
    differently during replay process, Retro simply uses the value in
    the replay process, and modifies its action graph to reflect these
    changes.]

    [HW: Currently I think the non-deterministic issue does not matter. Let's
    consider the two cases below:
    (1) The process prints out a different output to screen or other device,
    then there is a conflict which notifies the user the behavior has changed.
    (2) The process does not print a different output. In the case, a user or
    server has no way to recognize the difference between the replay process
    and the original process. Therefore repeating the original pattern of input
    is the reasonable behavior.
    The interesting point here is that in we can look at the problem in a
    user's point of view. When some information is input into the system, it is
    not distinguishable that which thread actually takes it. So no matter how
    the threads are scheduled, a user cannot see through the difference, thus
    the user usually will not input something differently.] 

------------------------------------------
------------- Replacement ----------------
------------------------------------------
This part shall be easily carried out by using ptracing to hack the return
field with the recorded value. We also need to skip the execution of the certain
action whose return field is hacked.

    [MW: which actions do you need to skip executing? (I didn't follow
    the last sentence).]
    [HW: text changed to be more precise.]

------------------------------------------
------------ Additional Problems ---------
------------------------------------------
What will happen if a process asks the user ``What is the current time?'' and
modifies the system time according to the user's input?
Current Approach: in replaying, modify system time to the recorded value. The
behavior does not look like quite reasonable.

------------------------------------------
------------ Select and poll -------------
------------------------------------------
Select and poll are system calls regarding i/o. For example, when vim wants to
read something from stdin, it first uses ``select'' to wait until stdin is able
to prove some input value, and then calls ``read'' to get the values. As a
result, we must deal with these two system calls, otherwise we cannot handle
user inputs in most cases.

The most simple way to deal with that is to treat select and poll as if they are
user inputs. Thus we can replace the return value of them to a recorded value
and solves the issue. Matching and replacement should be the same. We just need
to define the detection process. 

The detection process is not trivial: both system calls could be used to
determine the status of fd used as either an input or an output fd. In our
design, input actions and output actions must be treated differently: If an
input action is a user input stated above, we replace the action result with a
recorded action's value if possible. If an output action is taken, we usually do
not replace it. However if the action is different from previous recorded
action, we may need to report a conflict.

Only detecting whether a user input fd is placed in the input is not quite
enough: perhaps the system call is used with multiple fd's, and one of the fd's
that are not a user input is ready. At the time, replcing the return value with
the recorded value is not quite fair. For example, previous a user input fd f1
and another fd(say an output fd f2) are ready. However, in the replay process,
f2 is not ready. If we replace the return value of the system call with
recorded, the process will think f2 is ready falsely and do some undefined
things (like writing to a bad fd, etc).

As a result, here is a design for these system calls:
(1) Detection: Check that at least one of the ``read'' fd's satisfies the
condition in ``Detection'' section.
(2) Matching: A recorded system call matches the current system call if
  a. The OpCode is the same.
  b. The recorded system call is after any previously matched system call in the
  same process.
  c. The user input device set of the current system call and the recorded
  system call are the same. The other fd's do not matter.
(3) Replacement: Instead of putting everything into the current system call
return, we only put the user input fd's in the recorded system call back. All
the other fd's will not be put back.

