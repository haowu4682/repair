
Why do we need repair on browser-side?
--------------------------------------

Many webapp attacks, such as XSS attacks, execute in JS in the user's
browser. So, if the browser-side events are not included as part of
the repair, it would not be possible to redo only the legitimate
requests made by the browser and undo the effects of malicious
requests.

Design
------

During normal operation, JS events in the browser are recorded by a
browser extension, and these include HTTP requests and responses, UI
events, post messages etc., The page in which the event occurred and
the target DOM element of the event (if applicable) are also
recorded. Here, a page refers to the content loaded into a frame, and
every time a frame is (re-)loaded, it is assigned a new page id.

The page id is also added as a HTTP header to the request to have a
common way for the server and client to identify HTTP
requests. Additionally, for the server to differentiate between
requests from different users' browsers, each browser also has a
client id, which it attaches as a header to every request. The client
id is a random number generated by a user's browser when it starts up
the first time.

A key challenge in doing webapp repair is the multi-user nature of
webapps with state shared between users. This means that repairing one
user's state may trigger a repair for another user. Since requiring
all users to be online to do repair is not feasible, our solution to
this problem is to do repair on the server side. To do this, the
recorded browser logs are indexed by page id and each page's logs are
sent to the originating server for that page.

During repair, each page rendered by the browser is modeled as a page
actor, with individual HTTP requests in the page modeled as page
request actions. These request actions trigger server side actions
(such as executing a php script). When the repair manager decides that
a particular browser page needs to be repaired, it runs a browser,
which replays the user actions using the logs for that page. 

Multiple domains
----------------

Another key challenge in webapp repair is the distributed nature of
webapps. Webapps can have data that originates at different domains in
a single browser page, and the rules governing cross-domain data
access mean that a distributed repair mechanism may be necessary for
repairing such pages. This requires that the browser logs for a page
with cross-domain content be parititioned and sent to the servers of
the different domains whose content is on that page. This partitioning
should conform to the cross-domain security policies of today's
browsers, and as we describe below, the adhoc nature of some browser
security policies makes this process tricky.

There are two mechanisms for cross-domain data access in today's
webapps:

1. Using src attribute in img, script, and css elements.
2. Loading content from a different domain in a separate frame and
   using postMessage.

(XXX: ignoring HTML5 cross-domain access for now)

In the rest of this discussion, we use the term "home domain" to
indicate the domain in the main/top page, and "remote domain" to
indicate the different domain from which content is loaded into home
domain. 

In (1), the browser fetches the content from the remote domain and
injects it into the home domain content, as long as it is of the right
format. The security model is: (i) remote domain content should be of
the right format (ii) home domain content cannot read remote domain
content and (iii) if it is a JS, remote domain code runs in the
context of home domain. Designing a distributed repair mechanism for
this scenario, without involving the user's browser (ie., a trusted
third party where the repair happens), is tricky. However, we observe
that this method of cross-domain access is generally used between
mutually trusting domains (eg: facebook.com loading images from a
CDN). With that assumption, we can relax condition (ii) and that
allows for a distributed repair not involving the user's browser.

(TODO: validate that the mutual trust assumption above holds in
practice)

In (2), the browser loads the remote domain content in a separate
iframe, which can communicate with the home domain content (in the
main frame) using postMessage. The security model here is: (i) every
frame knows the window handles of all other frames and its position in
the frame hierarchy (ii) frames cannot read/write other's contents
(including reading location) directly (iii) writing to frame location
follows descendant policy (iv) communication using postMessage
requires the sender to know the domain of the recipient.

To support repairing this scenario, the browser creates a
public-private key pair for each frame. It includes the private key
along with the frame's logs that it sends to the frame's domain. The
public keys of all frames are sent with logs to every frame's
domain. The domains of the frames are not revealed to each other. The
public keys represent the window handles known to every frame, whereas
private keys represent the domain info in postMessage that only the
right senders know.

During repair, the repair manager on every domain (that is currently
involved), reruns the browser page with all frames except its own
replaced with stubs. Setting location on a frame translates to sending
a message to the repair manager on that location's domain indicating
that repair for this page/frame is in progress. This message is signed
with the private key of the frame doing the set so that the target
frame can check for descendant property. If setting the location is
allowed, the target's repair manager can then initiate the necessary
steps (rollback etc.,) needed to repair the particular frame on that
page. (If the frame did not load this url during original execution,
then that results in a UI conflict. Also, note that leaking
information regarding the frame doing the set is fine, since browsers
include this in the Referer information today).

Sending a postMessage translates to sending a message to the repair
manager on the recipient's domain, which is then forwarded to the
frame. The message is encrypted using the public key of the recipient
frame, and signed by the sender, so that only the right domain can
decrypt the message. This RPC-like location setting and postMessage
functionality can be implemented in the stubs for remote frames.

(XXX: how about if multiple pages/domains were loaded one after
another into the same frame? Do we give them different keys? NO, we
should be able to give them the same key, since the sender needs to
know the domain anyway).

UI conflicts:
-------------

Another key challenge in webapp repair is replaying user actions when
the web page may have changed during repair. A correct but
conservative approach is to not replay any actions if the web page
contents changed at all, and to get the user involved. However, this
would require significant user involvement during repair.

A better approach is to determine whether the web page changes are
relevant to the user action being replayed. For example, if the
changes were only to hidden DOM elements, and the visible part of the
web page did not change, then the user would have performed the same
action on the new page. So the action can be safely replayed on the
corresponding DOM element in the web page being repaired. The
intuition here is that attackers generally are stealthy and don't
change significant parts of user-visible pages. If they do, it is more
likely that some user will detect the attack and report it to the
site's admin thereby reducing the window of attack. Furthermore, a
change in the date or ad displayed on the page may not change the
action performed by the user, but changes to contents of a particular text
box may. And certainly, if during repair, an entirely different URL
is fetched (one that was not seen during recording), then the repair
manager cannot replay any user actions for that page. We call these
scenarios, where a UI action cannot be replayed, as a UI conflict (or
repair conflict).

To determine whether a UI action can be replayed, each action defines
three API calls, which are passed the state of both the old and new
web pages as input.

* action.conflict(oldDOM, oldCSS, newDOM, newCSS) -> bool
  - indicates whether the UI action can be replayed or not
* action.target(oldDOM, oldCSS, newDOM, newCSS)   -> DOMElement
  - if UI action does not conflict, the target DOM element in the page
    being replayed that corresponds to the one on the old page
* action.mark(oldDOM, oldCSS, newDOM, newCSS)     -> bool
  - if UI action does not conflict, whether it should be marked for
    user to audit it. This is useful if the action can sometimes be a
    conflict even though it can be replayed and it requires user audit
    to determine whether there was a conflict. If the user determines
    that it was a conflict, then the repair actions would be undone.

// XXX: simplify the above API

With regard to the oldDOM and oldCSS inputs to the API calls, 
since it is expensive to store the entire JS state of the browser
during recording, we recreate it at repair time,
by running an instance of the browser to which we feed the original
unmodified inputs. This also helps us check the validity of the
browser logs that were supplied to the server and hence ensure that
the user is not tampering with the logs.

Limitations:
------------
+ All users who want to use our system need to install a browser
  extension -- we don't think this is a huge burden, and if this is a
  useful functionality expect browsers to incorporate it.

