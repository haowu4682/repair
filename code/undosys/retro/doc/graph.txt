Overview
========

Retro uses a dependency graph to track the system. A dependency graph is
basically a bipartite graph consisting of two disjoint sets of nodes:
data nodes and action nodes. A data node can be a process or a file
that corresponds to some state, while an action node can be a syscall
that corresponds to some operation.

* Note that an action may reads from or writes to multiple data nodes.
  Therefore, a simple graph with data as nodes and action as edges may
  be bizarre because several edges may correspond to the _same_ action
  and are difficult to be repaired individually.

* It is possible to instead describe the model as a directed hypergraph,
  where a node is a data object and a hyperedge is a set of arcs among
  nodes. This documentation uses the bipartite graph model because it
  is easier to present.


Performance
===========

The log generated by Retro can be huge, so that the whole dependency
graph cannot fit in memory. Thus retro first builds a database where the
dependency graph is stored, and then reads data from the database for
reconstructing part of the graph when necessary. Graph objects use weak
references for linking each other so that (ideally) they can be garbage
collected once they are not actively used.

OS objects
==========

file: (dev, ino, gen)
(when to snapshot?)
[name, len] subobjects?

dentry: ((dev, ino, gen), name)
a special (dir, "..")

fifo: one-way connection

socket/pty: two-way connection

process: 
snapshot fdtable/pwd/choot/uid/gid/... before execve
